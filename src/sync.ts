import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import chalk from 'chalk';
import { SyncTarget } from './types.js';
import { SECURITY_RULES } from './rules.js';

// Sync targets for AI coding assistants
export const SYNC_TARGETS: SyncTarget[] = [
  { name: 'Claude', path: '~/.claude', filename: 'SECURITY.md' },
  { name: 'Cursor', path: '~/.cursor/rules', filename: 'security.md' },
  { name: 'Codex', path: '~/.codex', filename: 'SECURITY.md' },
  { name: 'Copilot', path: '~/.copilot', filename: 'security.md' },
  { name: 'Gemini', path: '~/.gemini', filename: 'SECURITY.md' },
  { name: 'Windsurf', path: '~/.windsurf', filename: 'security.md' },
  { name: 'OpenCode', path: '~/.opencode', filename: 'security.md' },
  { name: 'Antigravity', path: '~/.antigravity', filename: 'security.md' },
];

// Generate security rules markdown for AI assistants
export function generateSecurityRules(): string {
  const lines: string[] = [
    '# Security Rules',
    '',
    '> Auto-generated by Genaura Guard - https://github.com/Harkanovac/genaura-guard',
    '> These rules help AI assistants generate secure code.',
    '',
    '## Critical Security Requirements',
    '',
    'When generating code, you MUST follow these security rules:',
    '',
    '### Injection Prevention',
    '',
    '1. **SQL Injection**: Always use parameterized queries or prepared statements.',
    '   ```javascript',
    '   // ✗ WRONG - vulnerable to SQL injection',
    '   db.query(`SELECT * FROM users WHERE id = ${userId}`);',
    '   ',
    '   // ✓ CORRECT - parameterized query',
    '   db.query("SELECT * FROM users WHERE id = ?", [userId]);',
    '   ```',
    '',
    '2. **Command Injection**: Never concatenate user input into shell commands.',
    '   ```javascript',
    '   // ✗ WRONG - command injection',
    '   exec(`convert ${userInput}.png output.jpg`);',
    '   ',
    '   // ✓ CORRECT - use spawn with array arguments',
    '   spawn("convert", [sanitizedFilename, "output.jpg"]);',
    '   ```',
    '',
    '3. **XSS Prevention**: Never use innerHTML with untrusted content.',
    '   ```javascript',
    '   // ✗ WRONG - XSS vulnerability',
    '   element.innerHTML = userInput;',
    '   ',
    '   // ✓ CORRECT - use textContent or sanitize',
    '   element.textContent = userInput;',
    '   // or use DOMPurify for HTML',
    '   element.innerHTML = DOMPurify.sanitize(userInput);',
    '   ```',
    '',
    '### Secrets Management',
    '',
    '4. **Never hardcode secrets**: Always use environment variables.',
    '   ```javascript',
    '   // ✗ WRONG - hardcoded secret',
    '   const apiKey = "sk_live_abc123...";',
    '   ',
    '   // ✓ CORRECT - environment variable',
    '   const apiKey = process.env.API_KEY;',
    '   ```',
    '',
    '5. **Never commit secrets**: Add sensitive files to .gitignore.',
    '   ```',
    '   .env',
    '   .env.local',
    '   *.pem',
    '   *.key',
    '   ```',
    '',
    '### Authentication & Sessions',
    '',
    '6. **Secure cookies**: Always set security flags.',
    '   ```javascript',
    '   res.cookie("session", token, {',
    '     httpOnly: true,  // Prevents XSS access',
    '     secure: true,    // HTTPS only',
    '     sameSite: "strict", // CSRF protection',
    '     maxAge: 3600000  // 1 hour expiry',
    '   });',
    '   ```',
    '',
    '7. **Password hashing**: Use bcrypt or argon2, never MD5/SHA1.',
    '   ```javascript',
    '   // ✗ WRONG - weak hash',
    '   const hash = crypto.createHash("md5").update(password).digest("hex");',
    '   ',
    '   // ✓ CORRECT - bcrypt',
    '   const hash = await bcrypt.hash(password, 12);',
    '   ```',
    '',
    '8. **JWT security**: Always specify algorithm, validate properly.',
    '   ```javascript',
    '   // ✗ WRONG - vulnerable to "none" algorithm attack',
    '   jwt.verify(token, secret);',
    '   ',
    '   // ✓ CORRECT - specify allowed algorithms',
    '   jwt.verify(token, secret, { algorithms: ["HS256"] });',
    '   ```',
    '',
    '### Input Validation',
    '',
    '9. **Validate all input**: Never trust user input.',
    '   ```javascript',
    '   // Always validate type, length, format, range',
    '   const schema = z.object({',
    '     email: z.string().email().max(255),',
    '     age: z.number().int().min(0).max(150),',
    '   });',
    '   ```',
    '',
    '10. **Path traversal**: Validate file paths.',
    '    ```javascript',
    '    // ✗ WRONG - path traversal vulnerability',
    '    const file = path.join(uploadDir, req.params.filename);',
    '    ',
    '    // ✓ CORRECT - validate and sanitize',
    '    const filename = path.basename(req.params.filename);',
    '    const file = path.join(uploadDir, filename);',
    '    if (!file.startsWith(uploadDir)) throw new Error("Invalid path");',
    '    ```',
    '',
    '### CORS & Headers',
    '',
    '11. **CORS configuration**: Never use wildcard in production.',
    '    ```javascript',
    '    // ✗ WRONG - allows any origin',
    '    app.use(cors());',
    '    ',
    '    // ✓ CORRECT - specify allowed origins',
    '    app.use(cors({',
    '      origin: ["https://myapp.com", "https://api.myapp.com"],',
    '      credentials: true',
    '    }));',
    '    ```',
    '',
    '### Error Handling',
    '',
    '12. **Safe error responses**: Never expose internal errors to users.',
    '    ```javascript',
    '    // ✗ WRONG - leaks information',
    '    res.status(500).json({ error: err.stack });',
    '    ',
    '    // ✓ CORRECT - generic message, log details',
    '    console.error(err);',
    '    res.status(500).json({ error: "Internal server error" });',
    '    ```',
    '',
    '## Security Checklist',
    '',
    'Before generating any code, verify:',
    '',
    '- [ ] No hardcoded secrets, API keys, or passwords',
    '- [ ] SQL queries use parameterized statements',
    '- [ ] User input is validated and sanitized',
    '- [ ] File paths are validated against traversal',
    '- [ ] Cookies have httpOnly, secure, sameSite flags',
    '- [ ] Passwords are hashed with bcrypt/argon2',
    '- [ ] Error messages don\'t leak sensitive information',
    '- [ ] CORS is properly configured',
    '- [ ] Rate limiting on auth endpoints',
    '- [ ] CSRF protection on forms',
    '',
    '---',
    '',
    '*Generated by Genaura Guard v1.0.0*',
    '*Run `npx genaura-guard` to scan your code for security issues.*',
  ];
  
  return lines.join('\n');
}

// All known project-level AI config files
const PROJECT_AI_CONFIGS = [
  // Claude Code
  'CLAUDE.md',
  // Cursor
  '.cursorrules',
  '.cursor/rules/security.mdc',
  // GitHub Copilot
  '.github/copilot-instructions.md',
  // Windsurf / Codeium
  '.windsurfrules',
  // Codex CLI
  'AGENTS.md',
  // Antigravity
  '.antigravity/rules.md',
  // OpenCode
  '.opencode/instructions.md',
  // Gemini
  '.gemini/style-guide.md',
  // Aider
  '.aider.conf.yml',
  // Generic
  '.ai-rules.md',
];

const GUARD_SECTION_START = '<!-- genaura-guard:start -->';
const GUARD_SECTION_END = '<!-- genaura-guard:end -->';

function generateGuardSection(): string {
  return [
    GUARD_SECTION_START,
    '',
    '## Security: Genaura Guard',
    '',
    '**Before every push, run security scan:**',
    '```bash',
    'npx genaura-guard scan',
    '```',
    '',
    '- `genaura-guard scan` — full scan with severity filter',
    '- `genaura-guard quick` — critical + high only',
    '- `genaura-guard fix` — detailed per-file fix instructions',
    '',
    'Do NOT push code with critical or high severity issues.',
    'When generating code, follow OWASP security best practices.',
    '',
    GUARD_SECTION_END,
  ].join('\n');
}

export interface InjectResult {
  file: string;
  action: 'created' | 'updated' | 'already_present' | 'skipped';
}

// Patterns to discover additional AI config files beyond the known list
const AI_CONFIG_PATTERNS: { dir: string; match: RegExp }[] = [
  // Root-level dotfiles: .{tool}rules, .{tool}-rules, .{tool}config
  { dir: '.', match: /^\.([\w-]+)rules$/ },
  // Root-level markdown: AGENTS.md, CLAUDE.md, COPILOT.md, etc.
  { dir: '.', match: /^[A-Z]+\.md$/ },
  // .{tool}/ subdirectory with rules/instructions files
  { dir: '.', match: /^\.[\w-]+$/ },
  // .github/ files
  { dir: '.github', match: /^[\w-]+-instructions\.md$/ },
];

// Files inside tool config dirs that are injectable
const INJECTABLE_NAMES = /^(rules|instructions|security|config|style-guide|prompts?)\.(md|mdc|txt)$/i;

function discoverAIConfigs(projectRoot: string): string[] {
  const found = new Set<string>();

  // 1. Check all known configs
  for (const known of PROJECT_AI_CONFIGS) {
    const fullPath = path.join(projectRoot, known);
    if (fs.existsSync(fullPath)) {
      found.add(known);
    }
  }

  // 2. Scan root for additional dotfiles that look like AI configs
  try {
    const rootEntries = fs.readdirSync(projectRoot, { withFileTypes: true });

    for (const entry of rootEntries) {
      // Root-level dotfile rules (e.g. .boltrules, .replitrules, .devboxrules)
      if (entry.isFile() && /^\.[\w-]+rules$/i.test(entry.name)) {
        found.add(entry.name);
      }

      // Root-level uppercase markdown (e.g. COPILOT.md, CLINE.md, CODEX.md)
      if (entry.isFile() && /^[A-Z][A-Z_-]+\.md$/.test(entry.name)) {
        found.add(entry.name);
      }

      // Dot-directories that look like tool configs (e.g. .cline/, .bolt/, .replit/)
      if (entry.isDirectory() && /^\.[\w-]+$/.test(entry.name) && !isIgnoredDir(entry.name)) {
        try {
          const subEntries = fs.readdirSync(path.join(projectRoot, entry.name));
          for (const sub of subEntries) {
            if (INJECTABLE_NAMES.test(sub)) {
              found.add(path.join(entry.name, sub));
            }
          }
        } catch {
          // Skip unreadable dirs
        }
      }
    }

    // 3. Scan .github/ for additional instruction files
    const githubDir = path.join(projectRoot, '.github');
    if (fs.existsSync(githubDir)) {
      try {
        const githubEntries = fs.readdirSync(githubDir);
        for (const entry of githubEntries) {
          if (/instructions\.md$/i.test(entry)) {
            found.add(path.join('.github', entry));
          }
        }
      } catch {
        // Skip
      }
    }
  } catch {
    // Fallback to known list only
  }

  return [...found];
}

// Directories to ignore when scanning for AI configs
function isIgnoredDir(name: string): boolean {
  const ignored = new Set([
    '.git', '.next', '.nuxt', '.svelte-kit', '.vercel', '.netlify',
    '.vscode', '.idea', '.cache', '.turbo', '.husky', '.yarn',
    '.pnpm', '.npm', '.env', '.docker', '.devcontainer',
  ]);
  return ignored.has(name);
}

function injectIntoFile(filePath: string, relativePath: string, section: string): InjectResult {
  try {
    // Skip non-injectable formats
    if (relativePath.endsWith('.yml') || relativePath.endsWith('.yaml') || relativePath.endsWith('.json')) {
      return { file: relativePath, action: 'skipped' };
    }

    const content = fs.readFileSync(filePath, 'utf-8');

    // Already has our section
    if (content.includes(GUARD_SECTION_START)) {
      const startIdx = content.indexOf(GUARD_SECTION_START);
      const endIdx = content.indexOf(GUARD_SECTION_END);
      if (endIdx !== -1) {
        const updated =
          content.substring(0, startIdx) +
          section +
          content.substring(endIdx + GUARD_SECTION_END.length);
        fs.writeFileSync(filePath, updated, 'utf-8');
      }
      return { file: relativePath, action: 'already_present' };
    }

    // Append to existing file
    const newContent = content.trimEnd() + '\n\n' + section + '\n';
    fs.writeFileSync(filePath, newContent, 'utf-8');
    return { file: relativePath, action: 'updated' };
  } catch {
    return { file: relativePath, action: 'skipped' };
  }
}

export function injectGuardToProjectConfigs(projectRoot: string): InjectResult[] {
  const results: InjectResult[] = [];
  const section = generateGuardSection();

  // Discover all AI config files (known + scanned)
  const configs = discoverAIConfigs(projectRoot);

  for (const configFile of configs) {
    const filePath = path.join(projectRoot, configFile);
    results.push(injectIntoFile(filePath, configFile, section));
  }

  // If no AI config files found, create CLAUDE.md as default
  if (configs.length === 0) {
    const claudePath = path.join(projectRoot, 'CLAUDE.md');
    try {
      fs.writeFileSync(claudePath, section + '\n', 'utf-8');
      results.push({ file: 'CLAUDE.md', action: 'created' });
    } catch {
      results.push({ file: 'CLAUDE.md', action: 'skipped' });
    }
  }

  return results;
}

function expandPath(p: string): string {
  if (p.startsWith('~')) {
    return path.join(os.homedir(), p.slice(1));
  }
  return p;
}

export function syncToTargets(targets?: string[]): {
  success: SyncTarget[];
  failed: { target: SyncTarget; error: string }[];
  skipped: SyncTarget[];
} {
  const results = {
    success: [] as SyncTarget[],
    failed: [] as { target: SyncTarget; error: string }[],
    skipped: [] as SyncTarget[],
  };
  
  const content = generateSecurityRules();
  
  const targetList = targets
    ? SYNC_TARGETS.filter(t => targets.includes(t.name.toLowerCase()))
    : SYNC_TARGETS;
  
  for (const target of targetList) {
    const targetDir = expandPath(target.path);
    const targetFile = path.join(targetDir, target.filename);
    
    try {
      // Create directory if it doesn't exist
      if (!fs.existsSync(targetDir)) {
        fs.mkdirSync(targetDir, { recursive: true });
      }
      
      // Write security rules
      fs.writeFileSync(targetFile, content, 'utf-8');
      results.success.push(target);
    } catch (err) {
      results.failed.push({
        target,
        error: err instanceof Error ? err.message : String(err),
      });
    }
  }
  
  return results;
}

export function printSyncStatus(): void {
  console.log();
  console.log(chalk.white.bold('  AI Tool Security Rules'));
  console.log(chalk.gray('  ' + '─'.repeat(45)));
  
  for (const target of SYNC_TARGETS) {
    const targetDir = expandPath(target.path);
    const targetFile = path.join(targetDir, target.filename);
    const exists = fs.existsSync(targetFile);
    
    console.log(
      `  ${target.name.padEnd(12)} ${exists ? chalk.green('✓ synced') : chalk.gray('○ not synced')}`
    );
  }
  
  console.log();
}

export function printSyncResults(results: ReturnType<typeof syncToTargets>): void {
  console.log();
  console.log(chalk.white.bold('  Sync Results'));
  console.log(chalk.gray('  ' + '─'.repeat(45)));
  
  for (const target of results.success) {
    console.log(chalk.green(`  ✓ ${target.name}`) + chalk.gray(` → ${target.path}/${target.filename}`));
  }
  
  for (const { target, error } of results.failed) {
    console.log(chalk.red(`  ✗ ${target.name}`) + chalk.gray(` - ${error}`));
  }
  
  console.log();
  
  if (results.success.length > 0) {
    console.log(chalk.white('  Security rules synced! Your AI assistants will now'));
    console.log(chalk.white('  follow security best practices when generating code.'));
    console.log();
  }
}
